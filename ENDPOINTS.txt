SWAGGER: /swagger-ui.html

1. /public/signin(@RequestBody JwtRequest) -> return Login ResponseDTO
    500 error (BAD REQUEST) gone with JSON object:
    {
        field_name: what was invalid in this field,
        ....
    }
    {
        "token": string
        "role": string
    }


2. /createEvent(@RequestBody ObjHolder objHolder) -> returns response 200 after succesfull event insert.
   informacje dokładne co do objHolder na trello

3. /event/fetchDay?day={day} -> zwraca wszystkie eventy z danego dnia w postaci ResponseEventDTO
    day -> String w postaci yyyy-MM-dd, jako requestParam
    userEmail -> w requestBody jako string, nazwa username. username == empty, kiedy req jest przed zalogowaniem

    ResponseEventDTO -> {
         id: int, // id obiektu TimeEvent, ale z TimeEvent możemy wyciągnąć Event ofc
         organizationName: String;
         eventName: String;
         tags: String;
         language: String;
         dateS: LocalDateTime (w postaci yyyy-MM-dd);
         dateF: LocalDateTime (w postaci yyyy-MM-dd);
         timeEventId: id;
         ifSaved: boolean (czy jest zapisany w zakładce z zapisanymi przez danego użytkownika czy nie)
    }

4.Delete ->  /deleteSavedEvent" (@RequestBody Object), Object w postaci:
     {
         "userEmail": string, -> email aktualnie zalogowanego usera
         "id": int -> id wydarzenia które ma zostać usunięte z zapisanych dla konkretnego usera
     }

5.Put ->  /saveEventForUser" (@RequestBody Object), Object w postaci:
        {
            "userEmail": string, -> email aktualnie zalogowanego usera
            "id": int -> id wydarzenia które ma zostać dodane do zapisanych dla konkretnego usera
        }

6.Get -> /event/fetchPast -> zwraca wszystkie zakończone eventy danego użytkownika (lub te trawjące, ale już rozpoczęte)
	 w postaci ResponseEventDTO (format jak w punkcie 3)
	 userEmail -> w requestBody jako string, nazwa username. Bez tworzenia obiektu, tylko sam String. Identyfikuje użykownika.

7.Get -> /event/fetchFuture -> zwraca wszystkie przyszłe eventy danego użytkownika w postaci ResponseEventDTO (format jak w punkcie 3)
	 userEmail -> w requestBody jako string, nazwa username. Bez tworzenia obiektu, tylko sam String. Identyfikuje użykownika.

8. Get -> /fetchEvent/{id} -> zwraca szczegóły danego wydarzenia, id to id obiektu TimeEvent.
    W odpowiedzi dostajemy obiekt w postaci:
    {
        "name": string,
        "description": string,
        "daysOfWeek": string w postaci -> "mo,fr"
        "cyclical": boolean,
        "mode": string,
        "webAddress": string,
        "tags": string,
        "language": string,
        "dateS":  string -> sama data "2021-04-12",
        "dateF":  string -> sam data "2021-04-12",
        "timeS": string ->  sam czas
        "timeF": string ->  sam czas "18:00",
        "orgName": string,
        "orgLogo": string,
        "orgEmail": string,
        "orgWeb": string
    }

9. /public/fetchEvent/{id} - > zwraca to samo co w punkcie 8, ale z miejscu webAddress jest pusty string. Req nie zabezpieczony.



10. /public/register(@RequestBody UserDTO userDTO) -> rejestruje użytkownika. Zwraca response 200 przy poprawnym zapisaniu do bazy.


    Przyjmuje UserDTO w postaci:

    Przyjmuje NewUserDTO w postaci:
    {
        "name":String,
        "surname":String,
        "email":String,
        "pwd":String,
    }

11. /public/fetchOrganization?id={id} -> zwraca informacje o organizacji pod danym id.
    Pzyjmuje:
                id -> int w postaci requestParam.

    Zwraca organizacje w postaci:
    FullOrgResponseDTO -> {
             "name": String,
    	     "country": String,
    	     "province": String,
             "city": String,
             "postalCode": String,
             "street": String,
             "nip": String,
             "phoneNumber": String,
             "email": String,
             "webPage": String,
             "photo": String
        }
12. /public/table/fetchOrganizations -> zwraca informacje do tabelki z organizacjami

    ResponseOrgDTO {

            {
            "id": int
            "name": String,
            "photo": String,
            "city": String,
            "province": String
            "country": "String

    }

13. /admin/fetchAllEvent -> zwaraca wynik ResponseEventAdminDTO, dostępny tylko dla użytkowników zalogowanych jako admin i globalAdmin

    ResponseEventAdminDTO {
            "eventId": 1,
            "name": "Politechnika Wrocławska",
            "description": "aliquet molestie",
            "daysOfWeek": "th,fr,su,we",
            "cyclical": true,
            "mode": "sollicitudin",
            "webAddress": "nec mauris",
            "tags": "Prezentacja",
            "language": "Polski",
            "dateS": "2020-08-18",
            "dateF": "2022-02-22",
            "timeS": "12:47",
            "timeF": "08:18",
            "orgName": "Politechnika Wrocławska",
            "orgId": idOrganizacji
    }

14. /admin/deleteEvent/{id} -> usuwa event o podanym id przez Admina, zwraca 202 CREATED po poprawnym usunięciu eventu. Usuwa też
rekordy z tabeli TimeEvent

15. /admin/acceptEvent/{id} -> akceptuje event o poadanym id, dostepne tylko z konta Admina.

16. Delete ->  /admin/users/deleteUser/{id}" -> usuwa użytkownika o podanym id. Zwraca usunięty rekord w postaci:
     {
         "id",
         "name",
	 "surname",
	 "email",
	 "pwd", 
	 "role" -> jako string z nazwą roli.
     }

17. PUT -> /admin/users/updateUser -> aktualizuje dane użytkownika. Przyjmuje zaktualiozowane dane usera o podanym id w posatci:
        {
         	"id",
         	"name",
	 	"surname",
	 	"email",
	 	"pwd", 
	 	"role" -> jako typ Role
        }
	zwraca response w postaci
	{	
		"id",
         	"name",
	 	"surname",
	 	"email",
	 	"pwd", 
	 	"role" -> jako typ Role
	}

18. Get -> /admin/users/getOne/{id} -> zwraca użytwkonika o podanym id w postaci:
    {
      "id",
      "name",
	  "surname",
	  "email",
	  "pwd",
	  "role" -> jako string z nazwą roli.
     }

19. Get -> /admin/users/getOne/ -> Przyjmuje @RequestBody w postaci "String email". Zwraca użytwkonika o podanym email'u w postaci:
        {
         "id",
         "name",
    	 "surname",
    	 "email",
    	 "pwd",
    	 "role" -> jako string z nazwą roli.
         }

20. Get -> /admin/getUserList -> Przyjmuje @RequestParam w postaci "int page" i "int perPage". Zwraca daną stronę listy użytkowników użytwkoników:
        {
         "id",
         "name",
    	 "surname",
    	 "email",
    	 "pwd",
    	 "role" -> jako string z nazwą roli.
         }